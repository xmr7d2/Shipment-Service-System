"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = require("fs");
var path_1 = require("path");
var util_1 = require("util");
var zlib_1 = require("zlib");
var rollup_1 = require("rollup");
var isFunction = function (arg) {
    return typeof arg === 'function';
};
var isRegExp = function (arg) {
    return Object.prototype.toString.call(arg) === '[object RegExp]';
};
var readFilePromise = (0, util_1.promisify)(fs_1.readFile);
var writeFilePromise = (0, util_1.promisify)(fs_1.writeFile);
// functionality partially copied from rollup
/**
 * copied from https://github.com/rollup/rollup/blob/master/src/rollup/index.ts#L450
 */
function isOutputChunk(file) {
    return typeof file.code === 'string';
}
/**
 * Gets the string/buffer content from a file object.
 * Important for adding source map comments
 *
 * Copied partially from rollup.writeOutputFile
 * https://github.com/rollup/rollup/blob/master/src/rollup/index.ts#L454
 */
function getOutputFileContent(outputFileName, outputFile, outputOptions) {
    if (isOutputChunk(outputFile)) {
        var source = void 0;
        source = outputFile.code;
        if (outputOptions.sourcemap && outputFile.map) {
            var url = outputOptions.sourcemap === 'inline'
                ? outputFile.map.toUrl()
                : (0, path_1.basename)(outputFileName) + ".map";
            // https://github.com/rollup/rollup/blob/master/src/utils/sourceMappingURL.ts#L1
            source += "//# source" + ("MappingURL=" + url + "\n");
        }
        return source;
    }
    else {
        if (rollup_1.VERSION < '1.0.0') {
            return outputFile;
        }
        return typeof outputFile.source === 'string'
            ? outputFile.source
            : // just to be sure, as it is typed string | Uint8Array in rollup 2.0.0
                Buffer.from(outputFile.source);
    }
}
// actual plugin code
function gzipPlugin(options) {
    if (options === void 0) { options = {}; }
    if (rollup_1.VERSION < '0.60.0') {
        console.error('[rollup-plugin-gzip] This plugin supports rollup version >0.60.0!');
        console.error('For older rollup versions, please use version 1.x of this plugin.');
    }
    // check for old options
    if ('algorithm' in options) {
        console.warn('[rollup-plugin-gzip] The "algorithm" option is not supported any more! ' +
            'Use "customCompression" instead to specify a different compression algorithm.');
    }
    if ('options' in options) {
        console.warn('[rollup-plugin-gzip] The "options" option was renamed to "gzipOptions"!');
    }
    if ('additional' in options) {
        console.warn('[rollup-plugin-gzip] The "additional" option was renamed to "additionalFiles"!');
    }
    if ('delay' in options) {
        console.warn('[rollup-plugin-gzip] The "delay" option was renamed to "additionalFilesDelay"!');
    }
    var compressGzip = function (fileContent) {
        return new Promise(function (resolve, reject) {
            (0, zlib_1.gzip)(fileContent, options.gzipOptions || {}, function (err, result) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(result);
                }
            });
        });
    };
    var doCompress = options.customCompression || compressGzip;
    var mapFileName = isFunction(options.fileName)
        ? options.fileName
        : function (fileName) { return fileName + (options.fileName || '.gz'); };
    var plugin = {
        name: 'gzip',
        generateBundle: function (outputOptions, bundle, isWrite) {
            if (!isWrite)
                return;
            return Promise.all(Object.keys(bundle)
                .map(function (fileName) {
                var fileEntry = bundle[fileName];
                // file name filter option check
                var fileNameFilter = options.filter || /\.(js|mjs|json|css|html)$/;
                if (isRegExp(fileNameFilter) &&
                    !fileName.match(fileNameFilter)) {
                    return Promise.resolve();
                }
                if (isFunction(fileNameFilter) &&
                    !fileNameFilter(fileName)) {
                    return Promise.resolve();
                }
                var fileContent = getOutputFileContent(fileName, fileEntry, outputOptions);
                // Vite incompatibility check
                if (fileName.endsWith('.js') &&
                    fileContent.toString().includes('__VITE_PRELOAD__')) {
                    return Promise.reject('[rollup-plugin-gzip] This version of rollup-plugin-gzip is not fully compatible with Vite.' +
                        ' Please upgrade to version 3.x');
                }
                // minSize option check
                if (options.minSize &&
                    options.minSize > fileContent.length) {
                    return Promise.resolve();
                }
                return Promise.resolve(doCompress(fileContent))
                    .then(function (compressedContent) {
                    var compressedFileName = mapFileName(fileName);
                    if (rollup_1.VERSION < '1.0.0') {
                        bundle[compressedFileName] =
                            compressedContent;
                    }
                    else {
                        bundle[compressedFileName] = {
                            type: 'asset',
                            name: compressedFileName,
                            fileName: compressedFileName,
                            isAsset: true,
                            source: compressedContent,
                        };
                    }
                })
                    .catch(function (err) {
                    console.error(err);
                    return Promise.reject('[rollup-plugin-gzip] Error compressing file ' +
                        fileName);
                });
            })
                .concat([
                (function () {
                    if (!options.additionalFiles ||
                        !options.additionalFiles.length)
                        return Promise.resolve();
                    var compressAdditionalFiles = function () {
                        return Promise.all(options.additionalFiles.map(function (filePath) {
                            return readFilePromise(filePath)
                                .then(function (fileContent) {
                                return doCompress(fileContent);
                            })
                                .then(function (compressedContent) {
                                return writeFilePromise(mapFileName(filePath), compressedContent);
                            })
                                .catch(function (err) {
                                return Promise.reject('[rollup-plugin-gzip] Error compressing additional file ' +
                                    filePath +
                                    '. Please check the spelling of your configured additionalFiles. ' +
                                    'You might also have to increase the value of the additionalFilesDelay option.');
                            });
                        }));
                    };
                    // additional files can be processed outside of rollup after a delay
                    // for older plugins or plugins that write to disk (curcumventing rollup) without awaiting
                    var additionalFilesDelay = options.additionalFilesDelay ||
                        (rollup_1.VERSION >= '2.0.0' ? 0 : 2000);
                    if (additionalFilesDelay) {
                        setTimeout(compressAdditionalFiles, additionalFilesDelay);
                        return Promise.resolve();
                    }
                    else {
                        return compressAdditionalFiles();
                    }
                })(),
            ]));
        },
    };
    return plugin;
}
exports.default = gzipPlugin;
