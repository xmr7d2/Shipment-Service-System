import { readFile, writeFile } from 'fs';
import { basename } from 'path';
import { promisify } from 'util';
import { gzip } from 'zlib';
import { VERSION, } from 'rollup';
const isFunction = (arg) => typeof arg === 'function';
const isRegExp = (arg) => Object.prototype.toString.call(arg) === '[object RegExp]';
const readFilePromise = promisify(readFile);
const writeFilePromise = promisify(writeFile);
// functionality partially copied from rollup
/**
 * copied from https://github.com/rollup/rollup/blob/master/src/rollup/index.ts#L450
 */
function isOutputChunk(file) {
    return typeof file.code === 'string';
}
/**
 * Gets the string/buffer content from a file object.
 * Important for adding source map comments
 *
 * Copied partially from rollup.writeOutputFile
 * https://github.com/rollup/rollup/blob/master/src/rollup/index.ts#L454
 */
function getOutputFileContent(outputFileName, outputFile, outputOptions) {
    if (isOutputChunk(outputFile)) {
        let source;
        source = outputFile.code;
        if (outputOptions.sourcemap && outputFile.map) {
            const url = outputOptions.sourcemap === 'inline'
                ? outputFile.map.toUrl()
                : `${basename(outputFileName)}.map`;
            // https://github.com/rollup/rollup/blob/master/src/utils/sourceMappingURL.ts#L1
            source += `//# source` + `MappingURL=${url}\n`;
        }
        return source;
    }
    else {
        if (VERSION < '1.0.0') {
            return outputFile;
        }
        return typeof outputFile.source === 'string'
            ? outputFile.source
            : // just to be sure, as it is typed string | Uint8Array in rollup 2.0.0
                Buffer.from(outputFile.source);
    }
}
// actual plugin code
function gzipPlugin(options = {}) {
    if (VERSION < '0.60.0') {
        console.error('[rollup-plugin-gzip] This plugin supports rollup version >0.60.0!');
        console.error('For older rollup versions, please use version 1.x of this plugin.');
    }
    // check for old options
    if ('algorithm' in options) {
        console.warn('[rollup-plugin-gzip] The "algorithm" option is not supported any more! ' +
            'Use "customCompression" instead to specify a different compression algorithm.');
    }
    if ('options' in options) {
        console.warn('[rollup-plugin-gzip] The "options" option was renamed to "gzipOptions"!');
    }
    if ('additional' in options) {
        console.warn('[rollup-plugin-gzip] The "additional" option was renamed to "additionalFiles"!');
    }
    if ('delay' in options) {
        console.warn('[rollup-plugin-gzip] The "delay" option was renamed to "additionalFilesDelay"!');
    }
    const compressGzip = fileContent => {
        return new Promise((resolve, reject) => {
            gzip(fileContent, options.gzipOptions || {}, (err, result) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(result);
                }
            });
        });
    };
    const doCompress = options.customCompression || compressGzip;
    const mapFileName = isFunction(options.fileName)
        ? options.fileName
        : (fileName) => fileName + (options.fileName || '.gz');
    const plugin = {
        name: 'gzip',
        generateBundle(outputOptions, bundle, isWrite) {
            if (!isWrite)
                return;
            return Promise.all(Object.keys(bundle)
                .map(fileName => {
                const fileEntry = bundle[fileName];
                // file name filter option check
                const fileNameFilter = options.filter || /\.(js|mjs|json|css|html)$/;
                if (isRegExp(fileNameFilter) &&
                    !fileName.match(fileNameFilter)) {
                    return Promise.resolve();
                }
                if (isFunction(fileNameFilter) &&
                    !fileNameFilter(fileName)) {
                    return Promise.resolve();
                }
                const fileContent = getOutputFileContent(fileName, fileEntry, outputOptions);
                // Vite incompatibility check
                if (fileName.endsWith('.js') &&
                    fileContent.toString().includes('__VITE_PRELOAD__')) {
                    return Promise.reject('[rollup-plugin-gzip] This version of rollup-plugin-gzip is not fully compatible with Vite.' +
                        ' Please upgrade to version 3.x');
                }
                // minSize option check
                if (options.minSize &&
                    options.minSize > fileContent.length) {
                    return Promise.resolve();
                }
                return Promise.resolve(doCompress(fileContent))
                    .then(compressedContent => {
                    const compressedFileName = mapFileName(fileName);
                    if (VERSION < '1.0.0') {
                        bundle[compressedFileName] =
                            compressedContent;
                    }
                    else {
                        bundle[compressedFileName] = {
                            type: 'asset',
                            name: compressedFileName,
                            fileName: compressedFileName,
                            isAsset: true,
                            source: compressedContent,
                        };
                    }
                })
                    .catch((err) => {
                    console.error(err);
                    return Promise.reject('[rollup-plugin-gzip] Error compressing file ' +
                        fileName);
                });
            })
                .concat([
                (() => {
                    if (!options.additionalFiles ||
                        !options.additionalFiles.length)
                        return Promise.resolve();
                    const compressAdditionalFiles = () => Promise.all(options.additionalFiles.map(filePath => readFilePromise(filePath)
                        .then(fileContent => doCompress(fileContent))
                        .then(compressedContent => {
                        return writeFilePromise(mapFileName(filePath), compressedContent);
                    })
                        .catch((err) => {
                        return Promise.reject('[rollup-plugin-gzip] Error compressing additional file ' +
                            filePath +
                            '. Please check the spelling of your configured additionalFiles. ' +
                            'You might also have to increase the value of the additionalFilesDelay option.');
                    })));
                    // additional files can be processed outside of rollup after a delay
                    // for older plugins or plugins that write to disk (curcumventing rollup) without awaiting
                    const additionalFilesDelay = options.additionalFilesDelay ||
                        (VERSION >= '2.0.0' ? 0 : 2000);
                    if (additionalFilesDelay) {
                        setTimeout(compressAdditionalFiles, additionalFilesDelay);
                        return Promise.resolve();
                    }
                    else {
                        return compressAdditionalFiles();
                    }
                })(),
            ]));
        },
    };
    return plugin;
}
export default gzipPlugin;
